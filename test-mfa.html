<!DOCTYPE html>
<html>
<head>
    <title>MFA Test</title>
    <meta charset="UTF-8">
</head>
<body>
    <h1>MFA TOTP 테스트</h1>
    
    <div>
        <h2>1. Secret 생성</h2>
        <button onclick="generateTestSecret()">새 Secret 생성</button>
        <p>Secret: <code id="testSecret"></code></p>
        <p>OTP Auth URL: <code id="otpUrl" style="word-break: break-all;"></code></p>
    </div>
    
    <div>
        <h2>2. 현재 시간 정보</h2>
        <p>현재 시간: <span id="currentTime"></span></p>
        <p>Unix Timestamp: <span id="unixTime"></span></p>
        <p>Time Counter: <span id="timeCounter"></span></p>
    </div>
    
    <div>
        <h2>3. TOTP 생성</h2>
        <input type="text" id="secretInput" placeholder="Secret 입력" style="width: 300px;">
        <button onclick="generateCode()">코드 생성</button>
        <p>생성된 코드: <strong id="generatedCode" style="font-size: 24px;"></strong></p>
        <p>다음 코드까지: <span id="countdown"></span>초</p>
    </div>
    
    <div>
        <h2>4. TOTP 검증</h2>
        <input type="text" id="verifySecret" placeholder="Secret" style="width: 300px;">
        <input type="text" id="verifyCode" placeholder="6자리 코드" maxlength="6">
        <button onclick="verifyCode()">검증</button>
        <p id="verifyResult"></p>
    </div>

    <script>
        // Base32 decode function
        function base32Decode(secret) {
            const base32Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            let hex = '';
            
            secret = secret.replace(/\s/g, '').toUpperCase();
            
            for (let i = 0; i < secret.length; i++) {
                const val = base32Chars.indexOf(secret.charAt(i));
                if (val === -1) throw new Error('Invalid base32 character');
                bits += val.toString(2).padStart(5, '0');
            }
            
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                hex += parseInt(bits.substr(i, 8), 2).toString(16).padStart(2, '0');
            }
            
            return hex;
        }

        function hexToBytes(hex) {
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        async function generateHOTP(secret, counter) {
            const key = hexToBytes(base32Decode(secret));
            const counterBytes = new Uint8Array(8);
            
            for (let i = 7; i >= 0; i--) {
                counterBytes[i] = counter & 0xff;
                counter = Math.floor(counter / 256);
            }
            
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                key,
                { name: 'HMAC', hash: 'SHA-1' },
                false,
                ['sign']
            );
            
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, counterBytes);
            const signatureArray = new Uint8Array(signature);
            
            const offset = signatureArray[signatureArray.length - 1] & 0x0f;
            const code = (
                ((signatureArray[offset] & 0x7f) << 24) |
                ((signatureArray[offset + 1] & 0xff) << 16) |
                ((signatureArray[offset + 2] & 0xff) << 8) |
                (signatureArray[offset + 3] & 0xff)
            ) % 1000000;
            
            return code.toString().padStart(6, '0');
        }

        function generateTestSecret() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let secret = '';
            for (let i = 0; i < 32; i++) {
                secret += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            
            document.getElementById('testSecret').textContent = secret;
            document.getElementById('secretInput').value = secret;
            document.getElementById('verifySecret').value = secret;
            
            const otpUrl = `otpauth://totp/TestApp:testuser?secret=${secret}&issuer=TestApp`;
            document.getElementById('otpUrl').textContent = otpUrl;
            
            return secret;
        }

        async function generateCode() {
            const secret = document.getElementById('secretInput').value;
            if (!secret) {
                alert('Secret을 입력하세요');
                return;
            }
            
            try {
                const timeStep = 30;
                const currentTime = Math.floor(Date.now() / 1000);
                const counter = Math.floor(currentTime / timeStep);
                
                const code = await generateHOTP(secret, counter);
                document.getElementById('generatedCode').textContent = code;
                
                // 모든 시간 윈도우의 코드 표시
                console.log('Current counter:', counter);
                for (let i = -2; i <= 2; i++) {
                    const testCode = await generateHOTP(secret, counter + i);
                    console.log(`Window ${i}: ${testCode}`);
                }
            } catch (error) {
                alert('오류: ' + error.message);
                console.error(error);
            }
        }

        async function verifyCode() {
            const secret = document.getElementById('verifySecret').value;
            const code = document.getElementById('verifyCode').value;
            
            if (!secret || !code) {
                alert('Secret과 코드를 입력하세요');
                return;
            }
            
            try {
                const timeStep = 30;
                const currentTime = Math.floor(Date.now() / 1000);
                const currentCounter = Math.floor(currentTime / timeStep);
                
                let valid = false;
                for (let i = -2; i <= 2; i++) {
                    const counter = currentCounter + i;
                    const expectedCode = await generateHOTP(secret, counter);
                    console.log(`Checking window ${i}: Expected ${expectedCode}, Got ${code}`);
                    
                    if (expectedCode === code.padStart(6, '0')) {
                        valid = true;
                        document.getElementById('verifyResult').innerHTML = 
                            `<span style="color: green;">✓ 유효한 코드입니다! (Window: ${i})</span>`;
                        break;
                    }
                }
                
                if (!valid) {
                    document.getElementById('verifyResult').innerHTML = 
                        `<span style="color: red;">✗ 잘못된 코드입니다.</span>`;
                }
            } catch (error) {
                alert('오류: ' + error.message);
                console.error(error);
            }
        }

        // 시간 정보 업데이트
        setInterval(() => {
            const now = new Date();
            const unixTime = Math.floor(now.getTime() / 1000);
            const timeCounter = Math.floor(unixTime / 30);
            const secondsLeft = 30 - (unixTime % 30);
            
            document.getElementById('currentTime').textContent = now.toLocaleString();
            document.getElementById('unixTime').textContent = unixTime;
            document.getElementById('timeCounter').textContent = timeCounter;
            document.getElementById('countdown').textContent = secondsLeft;
        }, 1000);
        
        // 초기 secret 생성
        generateTestSecret();
    </script>
</body>
</html>